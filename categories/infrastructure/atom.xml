<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Infrastructure | euccas.github.io]]></title>
  <link href="http://euccas.github.io/categories/infrastructure/atom.xml" rel="self"/>
  <link href="http://euccas.github.io/"/>
  <updated>2017-06-16T18:24:26-07:00</updated>
  <id>http://euccas.github.io/</id>
  <author>
    <name><![CDATA[euccas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Instagram Moved to Python 3]]></title>
    <link href="http://euccas.github.io/20170616/how-instagram-moved-to-python-3.html"/>
    <updated>2017-06-16T17:52:34-07:00</updated>
    <id>http://euccas.github.io/20170616/how-instagram-moved-to-python-3</id>
    <content type="html"><![CDATA[<p>Instagram, the famous brunch sharing app, presented in <a href="https://us.pycon.org/2017/">PyCon 2017</a> and gave a talk in the keynote session on “How Instagram moves to Python 3”. If you have 15 minutes, read the interview with the speakers, Hui Ding and Lisa Guo from Instagram Infrastructure team, <a href="**here**">https://thenewstack.io/instagram-makes-smooth-move-python-3/</a>. If you have 45 minutes, watch their PyCon talk video, <a href="**here**">https://www.youtube.com/watch?v=66XoCk79kjM</a>. If you have only 5 minutes, continue reading, <strong>right here</strong>.</p>

<p>Instagram’s backend, which serves over 400 million active users every day, is built on Python/Django stack. The decision on whether moving from Python 2 to Python 3, was really a decision on whether investing in a version of the language that was mature, but wasn’t going anywhere (Python 2 is expected to retire in 2020) – or the language that was the next version and had great and growing community support. The major motivations behind Instagram’s migration to Python 3 are:</p>

<ul>
  <li>Typing support for dev velocity</li>
  <li>Better performance than Python 2</li>
  <li>Community continues to make Python 3 better and faster</li>
</ul>

<p>The whole migration process took about 10 months, in roughly 3 stages.</p>

<p><img class="center" src="/images/post_images/2017/20170616-instagram_python3_00.png" width="480"></p>

<ul>
  <li>First off, the migration was done directly on the Master Branch, which means the developers were adding new features to the code while migration is ongoing. So in the beginning of the Mirgration process, infrastructure added support of Python 3 on the Master Branch to make the code be able to run on both Python 2 and Python 3 environment.</li>
  <li>Massive code modification for 3 months, with the help of Python package <a href="**modernize**">https://pypi.python.org/pypi/modernize</a>. Meanwhile upgraded Third-party packages to Python 3 (working rule: <em>No Python 3, no new package</em>). Also deleted unused, incompatible packages.</li>
  <li>Intensive unit testing for 2 months. One limitation is data compatibility issues typically do not show up in unit tests.</li>
  <li>Production rollout for another 4 months (push Python 3 to every developer’s sandbox)</li>
</ul>

<p>In the talk, Lisa shared the challenges they faced in the migration process and how did they solved those problems.</p>

<ul>
  <li>Differences in unicode, str, bytes. Solved by using helper functions.</li>
  <li>Pickle memcache data format incompatibility in Python 2 and Python 3. Solved by isolating memcaches for Python 2 and Python 3.</li>
  <li>Iterator differences, such as <code>map</code>. Solved by converting all maps to list in Python 3.</li>
  <li>Dictionary order is different in different Python versions, which caused differences in the dumped JSON data. Solved by forcing <code>sorted_keys</code> in <code>json.dump</code> function.</li>
  <li>With Python 3, while CPU instructions per request decreased by 12%, max requests per second (capacity) had 0% increase! Found the root cause in the code of checking memory configuration, and the issue was memory optimization condition was never met in Python 3 as “True” because of unicode issue. Solve by adding a magical character <strong><em>“b”</em></strong>, just like this:</li>
</ul>

<p><img class="center" src="/images/post_images/2017/20170616-instagram_python3_01.png" width="480"></p>

<p>In Feb 2017, Instagram’s stack completely dropped Python 2 and moved to Python 3 (v3.6). So far they’ve got this from Python 3:</p>

<p><img class="center" src="/images/post_images/2017/20170616-instagram_python3_02.png" width="480"></p>

<p>One more thing, in the talk Hui Ding also briefly discussed a few Python Efficiency Strategies that Instagram used to support the growing number of features and users:</p>

<ul>
  <li>Build extensive tools to profile and understand perf bottleneck</li>
  <li>Proactively push stable, critical components to C/C++, e.g., memcached access library</li>
  <li>Use Cythonization to improve performance</li>
  <li>Future ideas: Make the Django stack completely Async? Create a new python runtime?</li>
</ul>

<p>Changing an existing service to use a version of language can never be easy, especially when you cannot afford to breaking the existing services serving millions of people. Moving to Python 3 in 10 months must be a challenging process. “It can be done. It worths it. Make it happen. And Make Python 3 better.”</p>

<p>Nice work Instagram!</p>

<p><img class="center" src="/images/post_images/2017/20170616-instagram_python3_04.png" width="480"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A List of SoC Design and Verification Infrastructure Needs - Tools/Automation Flows (2013)]]></title>
    <link href="http://euccas.github.io/20170212/a-list-of-soc-design-and-verification-infrastructure-needs.html"/>
    <updated>2017-02-12T15:53:19-08:00</updated>
    <id>http://euccas.github.io/20170212/a-list-of-soc-design-and-verification-infrastructure-needs</id>
    <content type="html"><![CDATA[<p><em>This post was written in 2013, when I thought it was necessary to summarize infrastructure tools and flows needed in SoC design and verification, according to all my experience. Today when I checked on my old notes I found this one and would like to share it here. Later on I’ll update and expand this list according to my latest experience and knowledge in engineering tools and infrastructure for software and hardware development.</em></p>

<p>System-on-Chip design and verification process is a complicated one. Unlike the world of Web and Internet, the design and development of hardware products have higher risk and lower tolerance to any mistakes. SoC design and verification process requires collaborations from multiple teams and vendors. Lots of hard decisions to make. Lots of trade-offs to consider. Moreover, the nonrecurring-engineering (NRE) charge makes sufficient and solid verification a must with limited time and resource. Tools and automated flows are an essential part of any design house.</p>

<p>Here is a list of areas that need tools and flows for SoC software and hardware design and verification according to my experience.</p>

<!--more-->

<table>
<tr>
	<th>Usage Area of Tools/Flows</th>
	<th>Software</th>
	<th>Hardware</th>
	<th>Design Usage</th>
	<th>Verification Usage</th>
</tr>

<tr>
	<td>Test Generation</td>
	<td>x</td>
	<td>x</td>
	<td></td>
	<td>x</td>
</tr>

<tr>
	<td>Regression System</td>
	<td>x</td>
	<td>x</td>
	<td></td>
	<td>x</td>
</tr>

<tr>
	<td>Coverage Reporting</td>
	<td>x</td>
	<td>x</td>
	<td></td>
	<td>x</td>
</tr>

<tr>
	<td>Coding Style Check</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Code Review System</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Code Quality Analysis</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Build System</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
</tr>

<tr>
	<td>Version Control</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
</tr>

<tr>
	<td>Integration System</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Spec System</td>
	<td></td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>RTL Generation</td>
	<td></td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>TestBench Generation</td>
	<td></td>
	<td>x</td>
	<td></td>
	<td>x</td>
</tr>

<tr>
	<td>Synthesis</td>
	<td></td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Netlist Quality Analysis</td>
	<td></td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Power Analysis and Optimization</td>
	<td></td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>ECO Flow</td>
	<td></td>
	<td>x</td>
	<td>x</td>
	<td></td>
</tr>

<tr>
	<td>Issue/Bug Tracking System</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
</tr>

<tr>
	<td>Infrastructure: Linux/Windows machines, LSF</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
	<td>x</td>
</tr>

</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GTAC: The Uber Challenge of Cross-Application Testing]]></title>
    <link href="http://euccas.github.io/20160928/the-uber-challenge-of-cross-application-testinng.html"/>
    <updated>2016-09-28T23:17:30-07:00</updated>
    <id>http://euccas.github.io/20160928/the-uber-challenge-of-cross-application-testinng</id>
    <content type="html"><![CDATA[<p>Inspired by Matt Cutts’ TED talk: <a href="https://www.ted.com/talks/matt_cutts_try_something_new_for_30_days?language=en">Try something new for 30 days</a>, I’m starting a “30 Days of GTAC” project. Google’s Test Automation Conference <a href="https://developers.google.com/google-test-automation-conference/">GTAC</a> is an annual test automation conference which brings together engineers from industry and academia to discuss advances in test automation and related engineering tools. In my “30 Days of GTAC” project, I’ll review the topics presented on GTAC. My goal is having a better and deeper understanding in modern testing technologies, methodologies, strategies, and practices.</p>

<p>Get it started! Day#1 topic is:</p>

<p><strong>The Uber Challenge of Cross-Application/Cross-Device Testing</strong></p>

<!--more-->

<ul>
  <li>Presenter: Apple Chow (Uber), Bian Jiang (Uber)</li>
  <li><a href="https://www.youtube.com/watch?v=p6gsssppeT0&amp;list=PLSIUOFhnxEiCWGsN9t5A-XOhRbmz54IS1&amp;index=3">Video</a></li>
  <li><a href="https://docs.google.com/presentation/d/1vYXhkvgLKun72Ix91LQDDWZQdcY5VOBqKVvI1Y6riYo/pub">Slides</a></li>
</ul>

<p><strong>My takeaways</strong></p>

<ul>
  <li>The challenge: End-to-end tests require cross application communication (between rider app and driver app)</li>
  <li>Uber’s solution: Octopus
    <ul>
      <li>Octopus coordinates communication across different apps running on different devices</li>
      <li>This solution can be adopted for any tests that require coordination/communication across different apps or devices</li>
    </ul>
  </li>
  <li>What makes testing Uber’s mobile apps significantly different from testing Google Maps?</li>
  <li>Why (built) Octopus? Unified (iOS and Android). Extensible (Integrate with different UI testing frameworks). Parallelized. Signaling (enabling cross-app and cross-device testing).</li>
  <li>What does Octopus do? Prepare test targets. Run tests (handles signaling). Create test results reports. Pull test artifacts. Perform clean ups. All from simple command line.</li>
  <li>Signaling between driver test and rider test: Conducted with Test Host to improve the consistency. API readSignal (blocking), writeSignal (nonblocking). Test hosts and test targets are connected via USB (reliable).</li>
  <li>Apple Chow wrote about Octopus on <a href="http://eng.uber.com/rescued-by-octopus/">Uber Engineering</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
