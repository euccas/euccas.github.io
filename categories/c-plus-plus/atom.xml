<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | euccas.github.io]]></title>
  <link href="http://euccas.github.io/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://euccas.github.io/"/>
  <updated>2017-02-05T22:17:35-08:00</updated>
  <id>http://euccas.github.io/</id>
  <author>
    <name><![CDATA[euccas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Traditional C++ 02 Pointer and Reference]]></title>
    <link href="http://euccas.github.io/20170205/effective-traditional-c-plus-plus-02-pointer-and-reference.html"/>
    <updated>2017-02-05T22:18:59-08:00</updated>
    <id>http://euccas.github.io/20170205/effective-traditional-c-plus-plus-02-pointer-and-reference</id>
    <content type="html"><![CDATA[<p>Pointers and references are two fundamental data types in C++. They are useful, common and somewhat dangerous. Using them correctly, they could greatly improve the efficiency and performance of your program. On the other hand, using them incorrectly could lead to many problems such as memory leaks and buffer overflow.</p>

<h1 id="pointers">Pointers</h1>

<p>A pointer holds the address of a variable and can be used to perform any operation that could be directly done on the variable, such as accessing and modifying it. Here are a few facts of pointers:</p>

<ul>
  <li>When a pointer is defined, memory is allocated in the size of a pointer.</li>
  <li>The pointer is strongly typed, meaning the compiler retains an association with a pointer that it points to a type of value.</li>
  <li>Two pointers can equal to each other, such that changing one’s value also changes the other’s value.</li>
</ul>

<p><code>
int * p = new int;
*p = 1;
int * q = p;
*p = 2;
cout &lt;&lt; *q; // Outputs 2. * is the pointer dereferene operator
</code></p>

<ul>
  <li>The size of a pointer varies depending on the architecture: 32 bits on a 32-bit machine and 64 bits on a 64-bit machine.</li>
  <li>Pointer subtraction is allowed. The result of pointer subtraction is the distance of two pointers.</li>
</ul>

<p><code>
int a = 1;
int b = 2;
int * pa = &amp;a;
int * pb = &amp;b;
int pdis = pa - pb;
</code></p>

<ul>
  <li>Adding a pointer and a distance gets another meaningful pointer.</li>
</ul>

<p><code>
int * p = new int[2];
p[0] = 0;
p[1] = 1;
p++;
cout &lt;&lt; *p; // Outputs 1
</code></p>

<h1 id="references">References</h1>

<p>A reference is another name for a pre-existing object. It does not have memory of its own. In other words, a reference is only an alias. A few facts about references are:</p>

<ul>
  <li>You cannot create a reference without specifying where in memory it refers to. A reference cannot be null.</li>
</ul>

<p><code>
int x = 7;
int &amp; y = x; // Makes y a reference, initialized with the address of x
</code></p>

<ul>
  <li>You can create a free-standing reference as shown below:</li>
</ul>

<p><code>
const int &amp; a = 12;
</code></p>

<ul>
  <li>
    <p>A reference is immutable. You cannot reassign a reference to another piece of memory.</p>
  </li>
  <li>
    <p>When you use references in function calls and class method calls, you always want to make them const. This helps to eliminate the side effects of using references (because using reference sometimes is not obvious as using pointers, and people may not notice the unintended side effects could happen). The following example shows the possible side effects when using references:</p>
  </li>
</ul>

<p>```
int &amp; f(int &amp;x) {
    ++x;
    return x;
}</p>

<p>int main(int argc, char** argv)
{
    int i = 5;
    printf(“the value is %d\n”, i); // i is 5
    printf(“the value is %d\n”, f(i)); // f(i) is 6
    printf(“the value is %d\n”, i); // i is changed to 6 unindently
    return 0;
}</p>

<p>```</p>

<p>The good way is always using <code>const</code> when using references:</p>

<p>```
const int &amp; f(const int &amp; x) {
    static int y = x;
    ++y;
    return y;
}</p>

<p>int main(int argc, char** argv)
{
    int i = 5;
    printf(“the value is %d\n”, i); // i is 5
    printf(“the value is %d\n”, f(i)); // f(i) is 6
    printf(“the value is %d\n”, i); // i is 5
    return 0;
}
```</p>

<h1 id="functions-call-by-reference">Functions: Call by Reference</h1>

<p>By default, functions in C++ pass variables by value, which means that a copy of the value is made and that copy is used inside the function. This is called <strong>pass by value</strong>. However, passing references or pointers does the same thing and faster as the copying is skipped. Actually this is why references are created for C++, to allow <strong>call by reference</strong> so that you can pass large objects without worrying about stack overflow.</p>

<p>Before references, this can be done with pointers. Pass by pointers can do the same thing but it’s a little bit more complicated than using references.</p>

<p>Example of a “call by reference”:</p>

<p>```
 void func(const string &amp; fs)
 {
    print(“string value is %s\n”, fs.c_str());
 }</p>

<p>int main(int argc, char ** argv)
 {
    string s = “I’m a string!”;
    func(s); // Outputs: string value is I’m a string
    printf(“string is %s\n”, s.c_str()); // Outputs: string is I’m a string
    return 0;
 }</p>

<p>```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Traditional C++ (1): Qualifiers]]></title>
    <link href="http://euccas.github.io/20170130/effective-traditional-c-plus-plus-01-qualifiers.html"/>
    <updated>2017-01-30T21:41:11-08:00</updated>
    <id>http://euccas.github.io/20170130/effective-traditional-c-plus-plus-01-qualifiers</id>
    <content type="html"><![CDATA[<p>Recently I’m doing a review on C++ programming language. During the process, I found a few topics which are worth paying more attention to. I’ll write several posts about the related C++ tips and tactics. These topics are not specially for C++ 11 or 14, I therefore name this series of posts as “Effective Traditional C++”.</p>

<p>The first topic I’ll write about here is: <strong>Qualifiers</strong></p>

<p>C++ uses Qualifiers to adjust qualities of a variable or an object. In C++, there are two types of qualifiers: CV qualifiers and storage qualifiers.</p>

<h1 id="cv-qualifiers">CV Qualifiers</h1>

<p>CV qualifiers stands for Const and Volatile Qualifier. There are three types of CV qualifiers:</p>

<ul>
  <li>const</li>
  <li>volatile</li>
  <li>mutable</li>
</ul>

<h2 id="const-qualifier">const qualifier</h2>

<p><code>const</code> marks a variable or function as read-only or immutable. It’s value (or the return value of a function) cannot be changed once it’s been defined.</p>

<p>```</p>

<p>const int weekdays = 7;</p>

<p>const int * myptr1; // declares myptr1 is a pointer to a constant integer
int const * myptr2; // same as above, declares myptr2 is a pointer to a constant integer
// myptr1 and myptr2 can be changed to point to other const integers</p>

<p>int * const  myptr3; // declares myptr3 is constant pointer to a variable integer
int const * const myptr4; // declares myptr4 is constant pointer to a constant integer
// myptr3 and myptr4 cannot be changed once initialized</p>

<p>const char *Function1()
{ return “Some text”;}</p>

<p>```</p>

<h2 id="volatile-qualifier">volatile qualifier</h2>

<p><code>volatile</code> marks a variable that may be <strong>changed by another process</strong>. This is generally used for threaded code, or externally linked code. Often <code>volatile</code> is used to tell the compiler avoid aggressive optimization involving the qualified object because the value of the object might be changed by means that the compiler is not aware of.</p>

<p>```</p>

<p>volatile int maxcnt = 10;
int cnt = 0;
while (cnt &lt; maxcnt)
{
    // do something … 
}</p>

<p>```</p>

<h2 id="mutable-qualifier">mutable qualifier</h2>

<p><code>mutable</code> is used on data member to make it writable from a <code>const</code> qualified member function.</p>

<p>```</p>

<p>class A {
   mutable int x;
   int y;</p>

<p>public:
     void f1() {
       // “this” has type <code>A*</code>
       x = 1; // okay
       y = 1; // okay
     }
     void f2() const {
       // “this” has type <code>A const*</code>
       x = 1; // okay, because x is mutable qualified
       y = 1; // illegal, because f2 is const
     }
};</p>

<p>```</p>

<h1 id="storage-qualifiers">Storage Qualifiers</h1>

<p>Storage qualifiers determine the lifetime of the defined variables or functions. By default, a variable defined within a block has automatic lifetime, which is the duration of the block. There are three types of storage qualifiers:</p>

<ul>
  <li>static</li>
  <li>register</li>
  <li>extern</li>
</ul>

<h2 id="static-qualifier">static qualifier</h2>

<p><code>static</code> marks the variable is alive for the duration of the program. Static variables are commonly used for keeping <strong>state</strong> between instances of a given function or method. Static variables are stored globally, even if they are stored in a class.</p>

<h2 id="register-qualifier">register qualifier</h2>

<p><code>register</code> marks the variables as register variables, which are stored in processor registers. Register variables are faster and easier to access and operate on. Note using <code>register</code> only suggest the compiler that particular automatic variables should be allocated to CPU registers, if possible. The compiler may or may not actually store the variable in a register. Register variables should only be used if you have a detailed knowledge of the architecture and compiler for the computer you are using.</p>

<h2 id="extern-qualifier">extern qualifier</h2>

<p><code>extern</code> defines the variables or functions in a separate translation unit and are linked with the code by the linker step of the compiler. In other words, you can <strong>define</strong> variables or functions in some source files or classes, and use them in other source files/classes by using <code>extern</code> qualifier to <strong>declare</strong> them in other source files or classes.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Functors]]></title>
    <link href="http://euccas.github.io/20170115/c-plus-plus-functors.html"/>
    <updated>2017-01-15T20:20:07-08:00</updated>
    <id>http://euccas.github.io/20170115/c-plus-plus-functors</id>
    <content type="html"><![CDATA[<p>A <strong>functor</strong> is a powerful C++ entity that everyone who wants to master C++ needs to know. A functor, which is short for “<strong>function object</strong>”, is a C++ class that acts like a function. Functors can be called using the familiar function call syntax, and can yield values and accept parameters just like regular functions.</p>

<p>To create a functor, we create a class (or a struct) that overloads the function <code>operator()</code>. Note here the function is called <code>operator()</code>, and it’s not the <code>operator</code> function, i.e. <code>()</code>. We then create an instance of this class (or struct) to use the created functor.</p>

<h1 id="create-and-use-functors">Create and use functors</h1>

<p>Let’s look at two examples of creating and using a functor. In the first example, a functor is created with a <code>class</code>, and in the second example we use a <code>struct</code> to create the functor.</p>

<h2 id="example-create-a-functor-with-a-class">Example: Create a functor with a Class</h2>

<p>```</p>

<p>class MyFunctor {
public:
    void operator() (const string&amp; str) const {
        cout « str « endl;
    }
}</p>

<p>// Using functor:</p>

<p>MyFunctor functor; // create an instance of the functor class
functor(“This is a functor!”); // and “call” it</p>

<p>// equivalence:
cout « functor.operator()(23) « endl;</p>

<p>// You’ll see “This is a functor” printed out.</p>

<p>```</p>

<h2 id="example-create-a-functor-with-a-struct">Example: Create a functor with a Struct</h2>

<p>```</p>

<p>struct add_x {
  add_x(int x) : x(x) {}
  int operator()(int y) { return x + y; }
private:
  int x;
};</p>

<p>// Using functor:</p>

<p>add_x add42(42); // create an instance of the functor class
int i = add42(8); // and “call” it
assert(i == 50); // and it added 42 to its argument</p>

<p>std::vector<int> in;
std::vector<int> out;
// Pass a functor to std::transform, which calls the functor on every element 
// in the input sequence, and stores the result to the output sequence
std::transform(in.begin(), in.end(), out.begin(), add_x(1)); 
assert(out[i] == in[i] + 1); // for all i</int></int></p>

<p>```</p>

<h1 id="functors-access-class-data-members">Functors access class data members</h1>

<p>The key difference between a function and a functor is that a functor’s function call operator is a <em>member function</em> whereas a raw C++ function is a <em>free</em> function. This means that a functor can access the following information when being called:</p>

<ul>
  <li>Its local variables</li>
  <li>Its parameters</li>
  <li>Global variables</li>
  <li><strong>Class data members</strong></li>
</ul>

<p>If a functor’s <code>operator()</code> member function requires access to data beyond what can be communicated by its parameters, we can store that information as a data member inside the functor class. Since <code>operator()</code> is a member of the functor class, it can then access that data freely. The following example shows how a functor’s <code>operator()</code> function access the class’s private member <code>toAppend</code>.</p>

<p>```</p>

<p>class StringAppender {
public:
    // Constructor takes and stores a string.
    explicit StringAppender(const string &amp;str) : toAppend(str) {}</p>

<pre><code>// Operator() prints out a string, plus the stored suffix.
void operator() (const string &amp;str) const {
    cout &lt;&lt; str &lt;&lt; ' ' &lt;&lt; toAppend &lt;&lt; endl;
}
</code></pre>

<p>private:
    const string toAppend;
};</p>

<p>// Usage:
StringAppender myFunctor(“is awesome”);
myFunctor(“C++”);</p>

<p>// You’ll see “C++ is awesome” is printed out.</p>

<p>```</p>

<h1 id="functors-are-useful-in-stl-algorithms">Functors are useful in STL algorithms</h1>

<p>C++ STL algorithms use functors to increase the flexibility and efficiency. The most common uses for function objects are for generating data, for testing data, and for applying operations to data. here is an example of how STL <code>for_each</code> uses functors.</p>

<p>```</p>

<p>struct sum
{
    sum(int* t):total(t){};
    int* total;
    void operator()(int element)
    {
       *total += element;
    }
};</p>

<p>int main()
{
    int total = 0;
    sum s(&amp;total);
    int arr[] = {0, 1, 2, 3, 4, 5};
    std::for_each(arr, arr+6, s);
    cout « total « endl; // prints total = 15;
}</p>

<p>```</p>

<p><em>The reader of <a href="http://web.stanford.edu/class/cs106l/course-reader/Ch13_Functors.pdf">Stanford course CS106l</a> explains functors in detail.</em></p>
]]></content>
  </entry>
  
</feed>
