<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[euccas.github.io]]></title>
  <link href="http://euccas.github.io/atom.xml" rel="self"/>
  <link href="http://euccas.github.io/"/>
  <updated>2016-03-18T22:42:53-07:00</updated>
  <id>http://euccas.github.io/</id>
  <author>
    <name><![CDATA[euccas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What We Talk About When Talking About Building a Software System]]></title>
    <link href="http://euccas.github.io/blog/20160318/what-we-talk-about-when-talking-about-building-a-software-system.html"/>
    <updated>2016-03-18T20:29:40-07:00</updated>
    <id>http://euccas.github.io/blog/20160318/what-we-talk-about-when-talking-about-building-a-software-system</id>
    <content type="html"><![CDATA[<p>When I realize the fact that I have had experiences on almost every part of building a software system, I decide to take a notes about the important things I can think of about building a software system.</p>

<h1 id="what-problems-need-solve">What problems need solve?</h1>
<p>Business requirements
Technical challenges
Pain points of existing solutions</p>

<ul>
  <li>Slow?</li>
  <li>Human efforts?</li>
  <li>Unstable?</li>
  <li>Tedious?</li>
  <li>Workloads hard to be handled?</li>
  <li>Repeated work?</li>
</ul>

<h1 id="solution">Solution</h1>
<p>Address the requirements, challenges, and pain points
Are they any similar solutions, why they are not good enough?
What are the good things of the existing work? Can your solution reuse?
Unique value that your solution provides</p>

<h1 id="core-design-workflow">Core Design Workflow</h1>
<p>Like user story, from a user’s point of view, how does the system work
According to this flow, abstract the system workflow (architecture)
From the perspective of improving the efficiency and performance of the system, what’s the architecture should look like?</p>

<h1 id="core-design-algorithms">Core Design Algorithms</h1>
<p>The most important and complicated part of computation or process
This is supposed to be provide the unique value or functions</p>

<h1 id="core-design-architecture">Core Design Architecture</h1>
<p>Architecture for improving the efficiency and performance of the system</p>

<ul>
  <li>Messaging queue</li>
  <li>Micro-service</li>
  <li>Async</li>
  <li>??</li>
</ul>

<h1 id="back-end">Back End</h1>
<p>Need a server with database</p>

<h2 id="server">Server</h2>

<ul>
  <li>AWS</li>
  <li>Heroku</li>
</ul>

<h2 id="frameworkprogramming-languages">Framework/Programming Languages:</h2>

<ul>
  <li>Ruby on Rails</li>
  <li>Java</li>
  <li>Python</li>
  <li>PHP</li>
</ul>

<h2 id="database">Database</h2>

<ul>
  <li>PostgreSQL</li>
  <li>MongoDB</li>
</ul>

<h2 id="backend---frontend-interface">Backend - Frontend interface</h2>

<ul>
  <li>database access (ruby on rails)</li>
  <li>http RESTful api</li>
  <li>Other methods? Nodejs?</li>
</ul>

<h1 id="front-end">Front End</h1>
<p>## Web/Web apps</p>

<h3 id="basics">Basics</h3>

<ul>
  <li>HTML5</li>
  <li>CSS</li>
  <li>SASS</li>
</ul>

<h3 id="responsive">Responsive</h3>

<ul>
  <li>Bootstrap</li>
</ul>

<h3 id="javascript">Javascript</h3>

<ul>
  <li>jQuery</li>
  <li>Angular</li>
  <li>Meteor</li>
  <li>React</li>
  <li>Node.js</li>
  <li>Iconic</li>
</ul>

<h3 id="data-visualization">Data Visualization</h3>

<ul>
  <li>D3</li>
  <li>C3</li>
  <li>HiChart</li>
  <li>GoogleCharts</li>
</ul>

<h2 id="native-mobile-app">Native Mobile App</h2>
<p>### iOS</p>

<ul>
  <li>Swift</li>
  <li>ObjectiveC</li>
</ul>

<h3 id="android">Android</h3>

<ul>
  <li>Java for Android</li>
</ul>

<h1 id="scheduler">Scheduler</h1>
<p>Jenkins</p>

<h1 id="logging">Logging</h1>
<p>??</p>

<h1 id="development-with-continuous-delivery">Development with Continuous Delivery</h1>

<h2 id="version-control">Version control</h2>

<ul>
  <li>git (github, bitbucket)</li>
  <li>perforce</li>
</ul>

<h2 id="testing-system-ci">Testing system (CI)</h2>

<ul>
  <li>??</li>
</ul>

<h2 id="configuration-management-devops">Configuration management, DevOps</h2>

<ul>
  <li>Chef</li>
  <li>Puppet</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Trello做项目管理初体验]]></title>
    <link href="http://euccas.github.io/blog/20160304/use-trello-for-managing-my-projects.html"/>
    <updated>2016-03-04T21:09:07-08:00</updated>
    <id>http://euccas.github.io/blog/20160304/use-trello-for-managing-my-projects</id>
    <content type="html"><![CDATA[<p>大概从18个月前开始，我开始习惯使用<a href="https://trello.com" target="_blank">Trello</a>作为project management and tracking的主要工具，也逐渐体会到Trello的特点和便利之处。总结起来，“不得不使用Trello”的理由有下面一些：</p>

<ul>
  <li>作为项目管理：无形之中的敏捷化</li>
  <li>作为问题记录：即使数目庞多的问题也能够清晰总览，便于分类，每一个问题同时可以有自己的详细记录</li>
  <li>自带的颜色标签和卡片aging效果非常方便呈现了项目总体和每一个task的状态</li>
  <li>一些插件提供了更强大的项目管理功能，比如burndown，甘特图等等</li>
  <li>最重要的特点也许是团队协同工作的便利：team members, assign task, comments. 虽然这一部分的功能我目前使用的还不多。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效Jenkins用户的第2个习惯]]></title>
    <link href="http://euccas.github.io/blog/20151215/jenkins-habits-2.html"/>
    <updated>2015-12-15T20:15:38-08:00</updated>
    <id>http://euccas.github.io/blog/20151215/jenkins-habits-2</id>
    <content type="html"><![CDATA[<p>本文内容部分来源于<strong>Andrew Bayer</strong>发布在SlideShare上的 <a href="http://www.slideshare.net/andrewbayer/seven-habits-of-highly-effective-jenkins-users-2014-edition"><em>7 habits of highly productive Jenkins Users (2014 Edition)</em></a>.</p>

<h3 id="section">习惯 2: 大而化小</h3>

<ol>
  <li>
    <p>使用多个Masters
     - 在存在多个project与team的情况下，多个master可以使jenkins jobs的管理更加敏捷和可控
     - 建议根据team, function, access(访问权限) 来划分master
     - 多个master使安装和升级plugin时需要的重启过程变得容易——不需要重启的master不会受到影响
     - 提高系统的稳定性：多个master, 每个master上分配较少数量的jobs，可以使整个系统更为稳定，减少遇到边界情况bug的几率</p>
  </li>
  <li>
    <p>分解jobs
     - 建议在Jenkins中使用模块化和重用，这一点的好处类似于在编程中使用模块化和重用
     - 多job的Build可以方便地在不同的project, release等等中重用
     - 分解job可以避免长时间运行的job在最后阶段出错，导致整个job需要被重新运行：多job的Build可以实现从其中任何一个子job处重新执行</p>
  </li>
  <li>
    <p>利用工具帮助分解jobs
     - 混合使用Parameterized trigger, Conditional Build Step, Copy Artifact, Promoted Builds：有效，但是配置困难
     - Build Pipeline plugin：可以把workflow可视化，集成手工步骤
     - Workflow plugin: 用DSL定义build steps之间的关系
     - Jenkins中有许多plugin和有关工具可以实现job分解</p>
  </li>
</ol>

<h3 id="jobjenkins-plugins">有关Job分解的Jenkins Plugins</h3>

<h4 id="build-pipeline-pluginhttpswikijenkins-ciorgdisplayjenkinsbuildpipelineplugin"><a href="https://wiki.jenkins-ci.org/display/JENKINS/Build+Pipeline+Plugin">Build Pipeline Plugin</a></h4>
<blockquote>
  <p>This plugin provides a Build Pipeline View of upstream and downstream connected jobs that typically form a build pipeline.  In addition, it offers the ability to define manual triggers for jobs that require intervention prior to execution, e.g. an approval process outside of Jenkins.</p>
</blockquote>

<h4 id="workflow-pluginhttpsgithubcomjenkinsciworkflow-pluginblobmasterreadmemdintroduction"><a href="https://github.com/jenkinsci/workflow-plugin/blob/master/README.md#introduction">Workflow plugin</a></h4>
<blockquote>
  <p>Building continuous delivery pipelines and similarly complex tasks in Jenkins using freestyle projects and traditional plugins can be awkward. You need to mix Parameterized Trigger, Copy Artifact, Promoted Builds, Conditional Build Step, and more just to express what should be a simple script. The Workflow plugin suite attempts to make it possible to directly write that script, what people often call a workflow (sometimes abbreviated flow), while integrating with Jenkins features like slaves and publishers.</p>
</blockquote>

<h4 id="parameterized-trigger-pluginhttpswikijenkins-ciorgdisplayjenkinsparameterizedtriggerplugin"><a href="https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Trigger+Plugin">Parameterized Trigger plugin</a></h4>
<blockquote>
  <p>This plugin lets you trigger new builds when your build has completed, with various ways of specifying parameters for the new build.
You can add multiple configurations: each has a list of projects to trigger, a condition for when to trigger them (based on the result of the current build), and a parameters section.</p>
</blockquote>

<h4 id="conditional-build-step-pluginhttpswikijenkins-ciorgdisplayjenkinsconditionalbuildstepplugin"><a href="https://wiki.jenkins-ci.org/display/JENKINS/Conditional+BuildStep+Plugin">Conditional Build Step plugin</a></h4>
<blockquote>
  <p>A buildstep wrapping any number of other buildsteps, controlling their execution based on a defined condition.</p>
</blockquote>

<h4 id="copy-artifact-pluginhttpswikijenkins-ciorgdisplayjenkinscopyartifactplugin"><a href="https://wiki.jenkins-ci.org/display/JENKINS/Copy+Artifact+Plugin">Copy Artifact plugin</a></h4>
<blockquote>
  <p>Adds a build step to copy artifacts from another project. The plugin lets you specify which build to copy artifacts from (e.g. the last successful/stable build, by build number, or by a build parameter). You can also control the copying process by filtering the files being copied, specifying a destination directory within the target project, etc. Click the help icon on each field to learn the details, such as selecting Maven or multiconfiguration projects or using build parameters. You can also copy from the workspace of the latest completed build of the source project, instead of its artifacts. All artifacts copied are automatically fingerprinted for you.</p>
</blockquote>

<h4 id="promoted-builds-pluginhttpswikijenkins-ciorgdisplayjenkinspromotedbuildsplugin"><a href="https://wiki.jenkins-ci.org/display/JENKINS/Promoted+Builds+Plugin">Promoted Builds plugin</a></h4>
<blockquote>
  <p>This plugin allows you to distinguish good builds from bad builds by introducing the notion of ‘promotion’.Put simply, a promoted build is a successful build that passed additional criteria (such as more comprehensive tests that are set up as downstream jobs.) The typical situation in which you use promotion is where you have multiple ‘test’ jobs hooked up as downstream jobs of a ‘build’ job. You’ll then configure the build job so that the build gets promoted when all the test jobs passed successfully. This allows you to keep the build job run fast (so that developers get faster feedback when a build fails), and you can still distinguish builds that are good from builds that compiled but had runtime problems.</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效Jenkins用户的第1个习惯]]></title>
    <link href="http://euccas.github.io/blog/20151210/jenkins-habits-1.html"/>
    <updated>2015-12-10T19:32:57-08:00</updated>
    <id>http://euccas.github.io/blog/20151210/jenkins-habits-1</id>
    <content type="html"><![CDATA[<p>本文内容部分来源于<strong>Andrew Bayer</strong>发布在SlideShare上的 <a href="http://www.slideshare.net/andrewbayer/seven-habits-of-highly-effective-jenkins-users-2014-edition"><em>7 habits of highly productive Jenkins Users (2014 Edition)</em></a>.</p>

<h3 id="jenkins-master">习惯 1: 保持Jenkins Master的稳定与可恢复</h3>

<ol>
  <li>
    <p>使用LTS Release
     - LTS release每12周发布一个新版本
     - LTS release版本发布都会保证通过自动化的acceptance testing和手工testing matrix</p>
  </li>
  <li>
    <p>不要急于升级plugins，保持谨慎
     - plugin的升级可能包含非常多的变化
     - 不是所有的升级都会保证向前兼容。比如最近Extended Email Plugin的升级，就造成之前的recipient/trigger配置不可用
     - 新功能也许不稳定</p>
  </li>
  <li>
    <p>对升级进行测试
     - 建议在测试环境中对升级和新的plugin进行测试，之后再进行production环境的升级
     - 建立针对plugin功能的测试
     - 在更大的规模进行测试
     - 大的改变需要至少经过几天的测试</p>
  </li>
  <li>
    <p>备份Jenkins Configuration
     - 建议使用<a href="https://wiki.jenkins-ci.org/display/JENKINS/thinBackup">thinBackup plugin</a>
     - 可以通过对$JENKINS_HOME做整体备份实现有效的备份，缺点是速度慢和占用较多的存储空间
     - Jenkins支持仅仅备份config files，而不需要备份所有的builds。参考<a href="https://gist.github.com/abayer/527063a4519f205efc74">这个gist</a>中的代码实现这一功能。</p>
  </li>
  <li>
    <p>避免使用Maven job类型
     - Maven plugin中的Mavin job type可能存在一些问题，包括plugin support, lazy loading等等
     - 在大规模应用中可能会引起一些意外的问题，不建议使用</p>
  </li>
</ol>

<h3 id="lts-release">什么是LTS Release?</h3>
<p>Jenkins LTS Release: Jenkins Long-Term Support release. 类似于Ubuntu的LTS版本。</p>

<p>具体说明<a href="https://wiki.jenkins-ci.org/display/JENKINS/LTS+Release+Line">在这里</a>。</p>

<h3 id="jenkins-maven-jobs">关于Jenkins Maven Jobs</h3>
<p>在Jenkins中可以通过两种方式build Maven project
1. 使用一个 free-style project 和 Maven build step
2. 使用一个 Maven-style project (配置job type为Mavin job type)
推荐使用第一种方法，因为第二种方式可能会出现问题</p>

]]></content>
  </entry>
  
</feed>
